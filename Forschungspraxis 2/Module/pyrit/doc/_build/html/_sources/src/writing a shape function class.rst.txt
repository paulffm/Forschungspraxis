.. _Writing a shape function class:

==============================
Writing a shape function class
==============================

.. |yes| unicode:: U+2713
.. |no| unicode:: U+2717

Writing a shape function class is a rater complex task, since all different kinds of materials, boundary conditions and
excitations have to be considered. Furthermore, the assembly of the matrices must be efficiently implemented.

To make this task easier, the main structure is presented here. The contents are as follows:

1. `Matrix assembly routines`_
2. `Vector assembly routine`_

Matrix assembly routines
========================

In this category are the mass matrix and the curlcurl- or divgrad-matrix. The value here represents the material.
In `Tab 1`_, there are listed all different combinations of properties of the value.
For each combination there is also given the signature and the return type of value.
There are also the evaluation functions, their output data and the functions to calculate the matrix elements listed.
The names of the latter must be extended by the respective matrix name.
For example, in the file it would be "calc_curlcurl_function_scalar" instead of "calc_function_scalar".
Whenever the value is inhomogeneous or nonlinear, it is necessary to evaluate the value befor the calculation function can be used.
In this case, the output of the evaluation function can directly passed to the respective input of the calculation function.
Depending on the shape function class, it can be possible that not all of the shown kinds of value make sense.

To differ between the combinations of properties of value, `Code 1`_ can be used.

.. csv-table:: Table 1: Material processing in shape function routines
    :header-rows: 1
    :delim: :
    :name: Tab 1

    Homogeneous:Linear:Isotrop:Time dependent:Signature:Return:Evaluate:Data format:Calc function
    |yes|:|yes|:|yes|:|no|:value:float:No:float:calc_constant_scalar
    |yes|:|yes|:|yes|:|yes|:value():float:No:float:calc_constant_scalar
    |yes|:|yes|:|no|:|no|:value:2D:No:(2,2) array:calc_constant_tensor
    |yes|:|yes|:|no|:|yes|:value():2D:No:(2,2) array:calc_constant_tensor
    |yes|:|no|:|yes|:|yes| and |no|:value(e,kw):1D:eval_hom_nonlin_iso:(E,) array:calc_scalar_per_elem
    |yes|:|no|:|no|:|yes| and |no|:value(e,kw):3D:eval_hom_nonlin_aniso:(E,2,2) array:calc_tensor_per_elem
    |no|:|yes|:|yes|:|yes| and |no|:value(x,y):float:eval_inhom_lin_iso:(E,N) array:calc_function_scalar
    |no|:|yes|:|no|:|yes| and |no|:value(x,y):2D:eval_inhom_lin_aniso:(E,N,2,2) array:calc_function_tensor
    |no|:|no|:|yes|:|yes| and |no|:value(x,y,e,kw):float:eval_inhom_nonlin_iso:(E,N) array:calc_function_scalar
    |no|:|no|:|no|:|yes| and |no|:value(x,y,e,kw):2D:eval_inhom_nonlin_aniso:(E,N,2,2) array:calc_function_tensor

The values in this table are exemplarily for Cartesian coordinates in two dimensions.
For the signatures, see :py:class:`~pyrit.ValueHandler`.
`E` indicates the number of elements on the physical group and `N` indicats the number of evaluation points of the numerical integration.

The entries of the column "Calc function" are explained in `Tab 2`_.

.. csv-table:: Table 2: Explanations of calc functions
    :header-rows: 1
    :name: Tab 2

    Calc function,Explanation
    calc_constant_scalar,Takes one scalar value for all elements
    calc_constant_tensor,Takes a tensorial value for all elements
    calc_scalar_per_elem,Takes one scalar value for each element
    calc_tensor_per_elem,Takes one tensorial value for each element
    calc_function_scalar,Takes the evaluations at integration points of a scalar function on each element
    calc_function_tensor,Takes the evaluations at integration points of a tensorial function on each element

.. code-block:: python
    :caption: Code 1: Differ material properties
    :name: Code 1

    prop = material.get_property(mat_property_class)
    if prop.is_homogeneous:
        if prop.is_linear:
            if prop.is_isotropic:  # homogenous, linear, isotropic
                if prop.is_time_dependent:  # homogenous, linear, isotropic, time dependent
                    value = prop.value()
                else:  # homogenous, linear, isotropic, time independent
                    value = prop.value
                if isinstance(prop.value, ndarray):
                    if len(value.shape) == 1:
                        # One scalar value per element
                    elif len(value.shape) == 3:
                        # One tensor per element
                    else:
                        raise NotImplementedError('The values shape is not supported.')
                else:
                    # scalar value
            else:  # anisotropic
                # homogenous, linear, anisotropic
        else:  # nonlinear
            if prop.is_isotropic:
                # homogenous, nonlinear, isotropic
            else:  # anisotropic
                # homogenous, nonlinear, anisotropic
    else:  # inhomogeneous
        if prop.is_linear:
            if prop.is_isotropic:
                # inhomogeneous, linear, isotropic
            else:  # anisotropic
                # inhomogeneous, linear, anisotropic
        else:  # nonlinear
            if prop.is_isotropic:
                # inhomogeneous, nonlinear, isotropic
            else:  # anisotropic
                # inhomogeneous, nonlinear, anisotropic


For every case, the defined functions from `Tab 1`_ have to be called.
In the curlcurl-routine for example, the call for an inhomogeneous, linear and anisotropic material would be:

.. code-block:: python
    :caption: Code 2: Example for an inhomogeneous, linear and anisotropic material
    :name: Code 2

    # inhomogeneous, linear, anisotropic
    evaluations = eval_inhom_lin_aniso(prop.value, evaluation_points)
    calc_curlcurl_function_tensor(indices, i, j, v, weights, evaluation_points, evaluations,
                                  self.b, self.c, self.__determinant_b, self.s,
                                  self.mesh.elem2node)

Vector assembly routine
=======================

The load vector routine is in this category.
The value here represents the excitation, e.g. a charge density or a current density.
In `Tab 3`_, there are listed all different combinations of properties of the value.
The explanation of the calc functions can be found in `Tab 2`.

To differ between the combinations of properties of value, `Code 3`_ can be used.

.. csv-table:: Table 3: Excitation processing in shape function routines
    :header-rows: 1
    :delim: :
    :name: Tab 3

    Homogeneous:Linear:Time dependent:Signature:Return:Evaluate:Data format:Calc function
    |yes|:|yes|:|no|:value:float:No:float:calc_constant_scalar
    |yes|:|yes|:|yes|:value():float:No:float:calc_constant_scalar
    |yes|:|no|:|yes| and |no|:value(e,kw):1D:eval_hom_nonlin_iso:(E,) array:calc_scalar_per_elem
    |no|:|yes|:|yes| and |no|:value(x,y):float:eval_inhom_lin_iso:(E,N) array:calc_function_scalar
    |no|:|no|:|yes| and |no|:value(x,y,e,kw):float:eval_inhom_nonlin_iso:(E,N) array:calc_function_scalar

.. code-block:: python
    :caption: Code 3: Differ excitation properties
    :name: Code 3

    exci = excitations.get_exci(exci_id)
    if exci.is_homogeneous:
        if exci.is_linear:
            # homogenous, linear
            if exci.is_time_dependent:  # homogeneous, linear, time dependent
                value = exci.value()
            else:  # homogeneous, linear, time independent
                value = exci.value
            if isinstance(value, ndarray):
                # value is an array
            else:
                # value is a constant
        else:  # nonlinear
            # homogenous, nonlinear
    else:  # inhomogeneous
        if exci.is_linear:
            # inhomogeneous, linear
        else:  # nonlinear
            # inhomogeneous, nonlinear

Here, however, one has to deal with lower dimensional elements.
So for example if the simulation domain is two-dimensional, it is possible that there are zero- and one-dimensional entities where an excitation is defined on.


Boundary condition assembly routines
====================================

The value here represents the boundary condition.
In this category are the routines for Dirichlet, Neumann and Robin boundary conditions.
Since the boundary conditions cannot be treated the same way, they are considered separately.


Dirichlet boundary conditions
-----------------------------

At Dirichlet boundary conditions, the user gives the normal component of a field at the boundary, i.e. a one-dimensional value.
`Tab 4`_ summarizes the different cases.

.. csv-table:: Table 4: Dirichlet boundary condition processing in shape function routines
    :header-rows: 1
    :delim: :
    :name: Tab 4

    Homogeneous:Linear:Time dependent:Signature:Return:Evaluate:Data format:Calc function
    |yes|:|yes|:|no|:value:float:No:float:calc_constant_scalar
    |yes|:|yes|:|yes|:value():float:No:float:calc_constant_scalar
    |yes|:|no|:|yes| and |no|:value(e,kw):1D:eval_hom_nonlin_iso:(E,) array:calc_scalar_per_elem
    |no|:|yes|:|yes| and |no|:value(x,y):float:eval_inhom_lin_iso:(E,N) array:calc_function_scalar
    |no|:|no|:|yes| and |no|:value(x,y,e,kw):float:eval_inhom_nonlin_iso:(E,N) array:calc_function_scalar

Neumann boundary conditions
---------------------------

At Neumann boundary conditions, the user gives the tangential component of a field at the boundary.
Here, the components in all dimensions must be declared. Hence, value can return a vector.
The calc functions, however, may require the value in another dimension.
So even if value returns a vector, the calc function can require a scalar.
`Tab 5`_ summarizes the different cases.
Note the following: Since one gives the tangential component of a field, it is possible that the integrand changes even though the values for the field components were constant.
This is due to the dependency on the boundary.
Imagine for example a boundary where some edges point in x and some other point in y direction.
Specifying a neumann boundary condition where the tangential field is directed in x direction does not make sense for the in y directed edges.


.. csv-table:: Table 5: Neumann boundary condition processing in shape function routines
    :header-rows: 1
    :delim: :
    :name: Tab 5

    Homogeneous:Linear:Time dependent:Signature:Return:Evaluate:Data format:Calc function
    |yes|:|yes|:|no|:value:1D:No:float:calc_constant_scalar
    |yes|:|yes|:|yes|:value():1D:No:float:calc_constant_scalar
    |yes|:|no|:|yes| and |no|:value(e,kw):2D:eval_hom_nonlin_iso:(E,) array:calc_scalar_per_elem
    |no|:|yes|:|yes| and |no|:value(x,y):1D:eval_inhom_lin_iso:(E,N) array:calc_function_scalar
    |no|:|no|:|yes| and |no|:value(x,y,e,kw):1D:eval_inhom_nonlin_iso:(E,N) array:calc_function_scalar

Robin boundary conditions
-------------------------

Robin boundary conditions can be split up into a part that uses the Neumann boundary condition part and another part
that is is (in term of the table) tha same as the Dirichlet boundary condition part.


