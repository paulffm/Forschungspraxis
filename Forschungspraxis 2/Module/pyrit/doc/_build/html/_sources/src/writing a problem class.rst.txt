.. _Writing a specific problem class:

================================
Writing a specific problem class
================================

In this section, it is explained how to write a problem class for a specific type of problem (for example a harmonic, magnetic problem on an two-dimensional domain)

See also :ref:`Writing a specific solution class`.

All specific problem classes are located in :py:mod:`pyrit.problem`.
There should be one file for every type, where the static, harmonic and transient class are in one file.
The currently most complete type is for magnetic problems on axisymmetric domains. So this type may be the best to look something up.

There are three main things you should do in a specific problem class:

1. Type annotation
    Even if the constructor does not differ from the constructor of the super class, you should rewrite it and add the type annotations in the code and in the docstring. For example:

    .. code-block:: python

            def __init__(self, description: str,
                              axi_mesh: 'AxiMesh',
                              tri_axi_edge_shape_function: 'TriAxisymmetricEdgeShapeFunction',
                              regions: 'Regions',
                              materials: 'Materials',
                              boundary_conditions: 'BdryCond',
                              excitations: 'Excitations',
                              time_steps: np.ndarray):
                super().__init__(description, None, None, regions, materials,
                                 boundary_conditions, excitations, time_steps)

                self.mesh: 'AxiMesh' = axi_mesh
                self.shape_function: 'TriAxisymmetricEdgeShapeFunction' = tri_axi_edge_shape_function

    Notes:
        - The mesh and shape function parameter are correctly annotated (``'AxiMesh'`` instead of ``'Mesh'``).
        - The mesh and shape function parameter have here a more descriptive name (``axi_mesh`` instead of ``mesh``).
        - The mesh and shape function parameter are **not** passed to the constructor of the super class.
          Instead, they are set locally with an annotation. So the type is known inside the class.

2. Extending the consistency check
    There is a very general consistency check in :py:class:`~pyrit.problem.Problem`. It is likely that this needs to be extended. Don't forget to call this method when you overide it (:py:meth:`~pyrit.problem.Problem.consistency_check`).

3. Writing the solve routine
    This is probably the most important and most extensive thing to do.
    The method ``solve`` needs to be overwritten in order to be able to solve the problem.

    Notes:
        - Make sure to stick to the signature of the method you override (as they differ from the different problem classes).
        - Settings can be passed to the kwargs.
        - Make use of the function :py:meth:`pyrit.problem.Problem.solve_linear_system` when solving a linear system inside the solve routine.
        - All cases of for example nonlinear materials have to be checked in the routine.
        - The routine returns an object of the corresponding solution class.
          Make sure that you add information to this object, that already has been calculated.
          A good example is the mass matrix.
        - Note that the solve routine of transient problems has a different signature. It is explained in the documentation of :py:meth:`~pyrit.problem.TransientProblem.solve`.