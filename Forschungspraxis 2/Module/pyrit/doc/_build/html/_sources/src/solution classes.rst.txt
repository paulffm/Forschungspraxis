.. _Solution classes:

================
Solution classes
================

In this section, the structure of solution classes is explained and the purpose of each class is sketched.

For every problem class (see :ref:`Problem classes`), there is a solution class.
There is an abstract class :py:class:`~pyrit.solution.Solution` that handles the basic features.
Apart from this, there are three types os solutions:

1. Static solutions (class :py:class:`~pyrit.solution.StaticSolution`)
2. Harmonic solution (class :py:class:`~pyrit.solution.HarmonicSolution`)
3. Transient solutions (class :py:class:`~pyrit.solution.TransientSolution`)

Note that all these classes are abstract.

The purpose of the solution class is to manage the solution of the problem and the data structures that are needed for the post-porocessing. Furthermore, it provides methods for saving and loading. With the class attribute :py:attr:`~pyrit.solution.Solution.ignore_for_saving` and the method :py:attr:`~pyrit.solution.Solution.initialize_attributes` it also provides the functionality that not all attributes have to be saved.
It may be advantageous to save a minimal amount of information.
This is the solution of the problem and the data structures of the problem.
All other fields can be computed from these.
Because the fields should be implemented as properties, the private arguments of :py:class:`~pyrit.solution.Solution` need to be initialized after loading.


StaticSolution
--------------

The purpose of this class is to manage the solutions of static problems.


HarmonicSolution
----------------

The purpose of this class is to manage the solutions of harmonic problems.
It extends :py:class:`~pyrit.solution.Solution` by the handling of the frequency.


TransientSolution
-----------------

The purpose fo this class is to manage the solutions of transient problems.
It extends :py:class:`~pyrit.solution.Solution` by the handling of time steps.
Furthermore, it has some routines to get an index or indices of time steps, a routine for animating time dependent fields and one for interpolating solutions.
This class is the most complex of the three.

For a generalized way of handling the data of transient solutions, there are also some decorators defined that help writing the derived classes faster.
The usage of those is strongly recommended.