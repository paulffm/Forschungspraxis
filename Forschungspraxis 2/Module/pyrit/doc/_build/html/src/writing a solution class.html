<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writing a specific solution class &mdash; Documentation of Pyrit  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Writing a shape function class" href="writing%20a%20shape%20function%20class.html" />
    <link rel="prev" title="Writing a specific problem class" href="writing%20a%20problem%20class.html" />
<link rel="stylesheet" type="text/css"
     href="../_static/custom.css" />


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> Documentation of Pyrit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage%20and%20workflow.html">Usage and Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="create_geometry.html">Creating a geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyrit.html">Pyrit (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrit</span></code>)</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Pyrit</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="information%20for%20developers.html">Information for developers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="tutorials%20for%20developers.html">Tutorials for developers</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="problem%20classes.html">Problem classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="solution%20classes.html">Solution classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="writing%20a%20problem%20class.html">Writing a specific problem class</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Writing a specific solution class</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#static-and-harmonic-solutions">Static and harmonic solutions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transient-solutions">Transient solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="writing%20a%20shape%20function%20class.html">Writing a shape function class</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Documentation of Pyrit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="tutorials%20for%20developers.html">Tutorials for developers</a> &raquo;</li>
      <li>Writing a specific solution class</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/src/writing a solution class.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="writing-a-specific-solution-class">
<span id="id1"></span><h1>Writing a specific solution class<a class="headerlink" href="#writing-a-specific-solution-class" title="Permalink to this heading"></a></h1>
<p>In this section, it is explained how to write a solution class for a specific type of solution (for example a harmonic, magnetic solution on an two-dimensional domain)</p>
<p>See also <a class="reference internal" href="writing%20a%20problem%20class.html#writing-a-specific-problem-class"><span class="std std-ref">Writing a specific problem class</span></a>.</p>
<p>All specific solution classes are located in <a class="reference internal" href="solution.html#module-pyrit.solution" title="pyrit.solution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrit.solution</span></code></a>.
There should be one file for every type, where the static, harmonic and transient class are in one file.
The currently most complete type is for magnetic solution on axisymmetric domains. So this type may be the best to look something up.</p>
<p>In general, the static and harmonic solution classes are relatively similar. The solution is in both cases an one-dimensional array.
In contrast to that, the solution of transient problems is one one-dimensional array per time step, i.e. a teo-dimensional array.
Because of this difference, the main concept of static/harmonic and transient solutions differs as well.</p>
<section id="static-and-harmonic-solutions">
<h2>Static and harmonic solutions<a class="headerlink" href="#static-and-harmonic-solutions" title="Permalink to this heading"></a></h2>
<p>Because this two cases are so similar, it is advantageous to have for both the same superclass. The following steps can be implemented in this superclass.</p>
<ol class="arabic">
<li><dl>
<dt>Type annotation</dt><dd><p>Even if the constructor does not differ from the constructor of the superclass, you should rewrite it and add the type annotations in the code and in the docstring. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">vector_potential</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">axi_mesh</span><span class="p">:</span> <span class="s1">&#39;AxiMesh&#39;</span><span class="p">,</span>
             <span class="n">tri_axi_edge_shape_function</span><span class="p">:</span> <span class="s1">&#39;TriAxisymmetricEdgeShapeFunction&#39;</span><span class="p">,</span>
             <span class="n">regions</span><span class="p">:</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span>
             <span class="n">materials</span><span class="p">:</span> <span class="s1">&#39;Materials&#39;</span><span class="p">,</span>
             <span class="n">excitations</span><span class="p">:</span> <span class="s1">&#39;Excitations&#39;</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">vector_potential</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">regions</span><span class="p">,</span> <span class="n">materials</span><span class="p">,</span> <span class="n">excitations</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span> <span class="s1">&#39;AxiMesh&#39;</span> <span class="o">=</span> <span class="n">axi_mesh</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape_function</span><span class="p">:</span> <span class="s1">&#39;TriAxisymmetricEdgeShapeFunction&#39;</span> <span class="o">=</span> <span class="n">tri_axi_edge_shape_function</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<dl class="simple">
<dt>Notes:</dt><dd><ul class="simple">
<li><p>The mesh and shape function parameter are correctly annotated (<code class="docutils literal notranslate"><span class="pre">'AxiMesh'</span></code> instead of <code class="docutils literal notranslate"><span class="pre">'Mesh'</span></code>).</p></li>
<li><p>The mesh and shape function parameter have here a more descriptive name (<code class="docutils literal notranslate"><span class="pre">axi_mesh</span></code> instead of <code class="docutils literal notranslate"><span class="pre">mesh</span></code>).</p></li>
<li><p>The mesh and shape function parameter are <strong>not</strong> passed to the constructor of the superclass.
Instead, they are set locally with an annotation. So the type is known inside the class.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl>
<dt>Properties</dt><dd><p>All results from the post-processing should be accessible through properties.
So, it is only computed if needed and only once, if it is requested several times.
Example of the B-field of an magnetic solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@property</span>
<span class="k">def</span> <span class="nf">b_field</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_function</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_potential</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b_field</span>

<span class="nd">@b_field</span><span class="o">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">b_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_b_field</span> <span class="o">=</span> <span class="n">b_field</span>
</pre></div>
</div>
<p>In order for this to work even after a solution was loaded from the disk, the protected parameters (here <code class="docutils literal notranslate"><span class="pre">_b_field</span></code>) have to be initialized properly.
For this reason, add all the names of the protected parameters to <code class="docutils literal notranslate"><span class="pre">_property_attributes</span></code> .</p>
</dd>
</dl>
</li>
<li><dl>
<dt>FieldPlotter</dt><dd><p>In order to be able to have the plotting methods also in the superclass, a <a class="reference internal" href="autosummary/pyrit.solution.FieldPlotter.html#pyrit.solution.FieldPlotter" title="pyrit.solution.FieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldPlotter</span></code></a> is used. In the superclass, you only have to decide if you want to plot a scalar or vector field or equilines.
For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_energy_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">default_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;plot_3d&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;x_label&#39;</span><span class="p">:</span> <span class="s1">&#39;x axis&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="s1">&#39;y axis&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Energy density&#39;</span><span class="p">}</span>
    <span class="n">default_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_scalar_field</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_density</span><span class="p">,</span> <span class="o">**</span><span class="n">default_kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>In the static solution class, <code class="docutils literal notranslate"><span class="pre">self.plotter</span></code> has be set to a <a class="reference internal" href="autosummary/pyrit.solution.StaticFieldPlotter.html#pyrit.solution.StaticFieldPlotter" title="pyrit.solution.StaticFieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StaticFieldPlotter</span></code></a> and in harmonic solutions to <a class="reference internal" href="autosummary/pyrit.solution.HarmonicFieldPlotter.html#pyrit.solution.HarmonicFieldPlotter" title="pyrit.solution.HarmonicFieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">HarmonicFieldPlotter</span></code></a>.
The signature of the plot functions is the same for these two classes.</p>
</dd>
</dl>
</li>
</ol>
<p>If there are any post-processing results that cannot be implemented in the superclass, implement them with the same scheme in the subclass</p>
</section>
<section id="transient-solutions">
<h2>Transient solutions<a class="headerlink" href="#transient-solutions" title="Permalink to this heading"></a></h2>
<p>The design principles of transient solution classes differ from static or harmonic ones.
Because of the time-dependency, properties cannot be used for the results of the post-processing or for accessing the matrices. For all methods that return or set something that depends on time, there are the keyword arguments <code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">*,</span> <span class="pre">time=None,</span> <span class="pre">index=None</span></code>. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">b_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>So it can be given a <code class="docutils literal notranslate"><span class="pre">time</span></code> or an <code class="docutils literal notranslate"><span class="pre">index</span></code> of the time steps to determine what is returned or what is set. If neither <code class="docutils literal notranslate"><span class="pre">time</span></code> nor <code class="docutils literal notranslate"><span class="pre">index</span></code> is given, the whole parameter is returned or set.
Use the method <a class="reference internal" href="autosummary/pyrit.solution.TransientSolution.html#pyrit.solution.TransientSolution.get_index" title="pyrit.solution.TransientSolution.get_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_index()</span></code></a> to get the index for time steps.</p>
<p>There are six main things you should do in a specific transient solution class:</p>
<ol class="arabic">
<li><dl>
<dt>Annotation</dt><dd><p>Even if the constructor does not differ from the constructor of the superclass, you should rewrite it and add the type annotations in the code and in the docstring. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">vector_potential</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">axi_mesh</span><span class="p">:</span> <span class="s1">&#39;AxiMesh&#39;</span><span class="p">,</span>
             <span class="n">tri_axi_edge_shape_function</span><span class="p">:</span> <span class="s1">&#39;TriAxisymmetricEdgeShapeFunction&#39;</span><span class="p">,</span>
             <span class="n">regions</span><span class="p">:</span> <span class="s1">&#39;Regions&#39;</span><span class="p">,</span>
             <span class="n">materials</span><span class="p">:</span> <span class="s1">&#39;Materials&#39;</span><span class="p">,</span>
             <span class="n">excitations</span><span class="p">:</span> <span class="s1">&#39;Excitations&#39;</span><span class="p">,</span>
             <span class="n">time_steps</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">monitor_solutions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">description</span><span class="p">,</span> <span class="n">vector_potential</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">regions</span><span class="p">,</span>
                     <span class="n">materials</span><span class="p">,</span> <span class="n">excitations</span><span class="p">,</span> <span class="n">time_steps</span><span class="p">,</span> <span class="n">monitor_solutions</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span> <span class="s1">&#39;AxiMesh&#39;</span> <span class="o">=</span> <span class="n">axi_mesh</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">shape_function</span><span class="p">:</span> <span class="s1">&#39;TriAxisymmetricEdgeShapeFunction&#39;</span> <span class="o">=</span> <span class="n">tri_axi_edge_shape_function</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span> <span class="o">=</span> <span class="n">TransientFieldPlotter</span><span class="p">(</span><span class="n">axi_mesh</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">consistency_check</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>Notes:</dt><dd><ul class="simple">
<li><p>The mesh and shape function parameter are correctly annotated (<code class="docutils literal notranslate"><span class="pre">'AxiMesh'</span></code> instead of <code class="docutils literal notranslate"><span class="pre">'Mesh'</span></code>).</p></li>
<li><p>The mesh and shape function parameter have here a more descriptive name (<code class="docutils literal notranslate"><span class="pre">axi_mesh</span></code> instead of <code class="docutils literal notranslate"><span class="pre">mesh</span></code>).</p></li>
<li><p>The mesh and shape function parameter are <strong>not</strong> passed to the constructor of the superclass.
Instead, they are set locally with an annotation. So the type is known inside the class.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl>
<dt>Access to the solution</dt><dd><p>The solution itself should be accessed differently than all the derived values (see next point).
They should use the methods <code class="docutils literal notranslate"><span class="pre">_get_solution</span></code> and <code class="docutils literal notranslate"><span class="pre">_set_solution</span></code> from the superclass. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">vector_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_solution</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">set_vector_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector_potential</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_set_solution</span><span class="p">(</span><span class="n">vector_potential</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Derived values</dt><dd><p>For the derived values, i.e. the results from post-processing, there exist two decorators in <a class="reference internal" href="autosummary/pyrit.solution.Solution.html#pyrit.solution.Solution" title="pyrit.solution.Solution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrit.solution.Solution</span></code></a>, namely <code class="docutils literal notranslate"><span class="pre">get_field</span></code> and <code class="docutils literal notranslate"><span class="pre">set_field</span></code>.
These should be used for getting or setting these values. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@get_field</span><span class="p">(</span><span class="s1">&#39;_b_field&#39;</span><span class="p">,</span> <span class="s1">&#39;magnetic flux density&#39;</span><span class="p">,</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">b_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_function</span><span class="o">.</span><span class="n">curl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_potential</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">))</span>

<span class="nd">@set_field</span><span class="p">(</span><span class="s1">&#39;_b_field&#39;</span><span class="p">,</span> <span class="s1">&#39;magnetic flux density&#39;</span><span class="p">,</span> <span class="s1">&#39;ndarray&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">set_b_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b_field</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_set_types</span><span class="p">(</span><span class="n">b_field</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
</pre></div>
</div>
<p>For convenience, the “get_” at the beginning of the getter methods is omitted.</p>
<p>In the getter methods, one needs to return the respective field, assuming that the index is given (the decorator makes sure that it is)</p>
<p>In the setter methods, only the method <code class="docutils literal notranslate"><span class="pre">_check_set_types</span></code> has to be called. The rest is done in the decorator.</p>
<p>The decorators do also generate the docstring for the methods.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>Access matrices and vectors</dt><dd><p>Accessing the matrices or a vector is internal different handled as the derived values.
This is due to tha fact, that they can depend on the solution or time.
So this information has to be passed to the generating routines.
The usage is the same, though.</p>
<p>There are also two decorators in <a class="reference internal" href="autosummary/pyrit.solution.Solution.html#pyrit.solution.Solution" title="pyrit.solution.Solution"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyrit.solution.Solution</span></code></a>, namely <code class="docutils literal notranslate"><span class="pre">get_matrix</span></code> and <code class="docutils literal notranslate"><span class="pre">set_matrix</span></code>, that generalise the getting and setting process. They also set the docstring.</p>
<p>For the getter method an example is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@get_matrix</span><span class="p">(</span><span class="s1">&#39;_curlcurl_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;curl-curl matrix&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">curlcurl_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">],</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">]:</span>
    <span class="n">lin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">is_linear</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">Reluctivity</span><span class="p">)</span>
    <span class="n">time_dependent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">is_time_dependent</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">Reluctivity</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">lin</span><span class="p">:</span>
        <span class="n">static_solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_static_solution</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;solution&#39;</span><span class="p">,</span> <span class="n">static_solution</span><span class="p">,</span> <span class="n">prop_class</span><span class="o">=</span><span class="n">material</span><span class="o">.</span><span class="n">Reluctivity</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_dependent</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_steps</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">prop_class</span><span class="o">=</span><span class="n">material</span><span class="o">.</span><span class="n">Reluctivity</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">time_dependent</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_function</span><span class="o">.</span><span class="n">curlcurl_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">,</span> <span class="n">material</span><span class="o">.</span><span class="n">Reluctivity</span><span class="p">)</span>
</pre></div>
</div>
<p>This method has to check if the used <a class="reference internal" href="autosummary/pyrit.material.MatProperty.html#pyrit.material.MatProperty" title="pyrit.material.MatProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatProperty</span></code></a> (in the example it is <code class="docutils literal notranslate"><span class="pre">material.Reluctivity</span></code>) is linear or time dependent.
Depending on that if has to update the solution or the time in the materials.
It can be assumed that the index is present (the property ensures this).
The method then has to return a tuple, with a boolean and a simple function.
The boolean indicates if the <a class="reference internal" href="autosummary/pyrit.material.MatProperty.html#pyrit.material.MatProperty" title="pyrit.material.MatProperty"><code class="xref py py-class docutils literal notranslate"><span class="pre">MatProperty</span></code></a> depends on time (directly or indirectly) and the function return the respective matrix.</p>
<p>For the setter method an example is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@set_matrix</span><span class="p">(</span><span class="s1">&#39;_curlcurl_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;curl-curl matrix&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">set_curlcurl_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curlcurl_matrix</span><span class="p">:</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Here, all the content of the method can be handled in the decorator.
So it can just <code class="docutils literal notranslate"><span class="pre">pass</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>Plotting</dt><dd><p>The plotting is very similar to static or harmonic solutions.
It is also done with a <a class="reference internal" href="autosummary/pyrit.solution.FieldPlotter.html#pyrit.solution.FieldPlotter" title="pyrit.solution.FieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">FieldPlotter</span></code></a>.
The <a class="reference internal" href="autosummary/pyrit.solution.TransientFieldPlotter.html#pyrit.solution.TransientFieldPlotter" title="pyrit.solution.TransientFieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransientFieldPlotter</span></code></a> is used.
An example is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_energy_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_index</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="n">default_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;plot_3d&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;x_label&#39;</span><span class="p">:</span> <span class="s1">&#39;x axis&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="s1">&#39;y axis&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;Energy density&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_scalar_field</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_density</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">time_steps</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Animating</dt><dd><p>The animation is very similar to plotting.
It is also done with the <a class="reference internal" href="autosummary/pyrit.solution.TransientFieldPlotter.html#pyrit.solution.TransientFieldPlotter" title="pyrit.solution.TransientFieldPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransientFieldPlotter</span></code></a>.
An example is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">animate_energy_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_animation_indices</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="n">default_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x_label&#39;</span><span class="p">:</span> <span class="s1">&#39;x axis&#39;</span><span class="p">,</span> <span class="s1">&#39;y_label&#39;</span><span class="p">:</span> <span class="s1">&#39;y axis&#39;</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;Magnetic energy density&quot;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">default_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">animate_scalar_field</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_density</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>There is a method <code class="docutils literal notranslate"><span class="pre">get_animation_indices</span></code> to get the right indices.
Then, the default kwargs can be set and the appropriate animation function must be called.
They have the same name as the plt methods, where “plot” is replaced by “animate”.</p>
</dd>
</dl>
</li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="writing%20a%20problem%20class.html" class="btn btn-neutral float-left" title="Writing a specific problem class" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="writing%20a%20shape%20function%20class.html" class="btn btn-neutral float-right" title="Writing a shape function class" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>